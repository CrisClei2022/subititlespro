<!-
'salvar' funcionando.
->
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SUBTITLE PRO - Editor de Legenda Multi-Trecho Dark</title>
    <style>
        /* ================================== */
        /* CSS B√°sico e Tema Dark */
        /* ================================== */
        body {
            font-family: Arial, sans-serif;
            background-color: #1e1e1e;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .hidden {
          display: none !important;
        }

        section {
            padding: 10px;
            min-width: 350px; 
            max-width: 600px;
            border-radius: 8px;
            background-color: #2d2d2d;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        /* ================================== */
        /* Estilo para a Load e Save */
        /* ================================== */
		.load-group {
            display: flex;
            flex-direction: column;
            margin-top: 20px;
            gap: 8px;
            width: 100%;
        }
        
        /* ================================== */
        /* Estilo para a Lista de Legendas */
        /* ================================== */
        #lista-legendas {
            max-height: 50vh; /* ou a altura que preferir */
            overflow-y: auto;
            width: 100%;
        }
        
        .legenda-item {
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.15s;
            display: flex;
            gap: 15px;
            align-items: baseline;
            line-height: 1.4;
        }

        .legenda-item:hover {
            background-color: #3a3a3a;
        }

        /* Marca√ß√£o para o item que est√° atualmente sendo editado */
        .legenda-item.legenda-ativa {
            background-color: #5c7cfa; /* Fundo azul para o item ativo */
            color: #1e1e1e;
            font-weight: bold;
        }

        .legenda-item.legenda-ativa .timestamp,
        .legenda-item.legenda-ativa .legenda-id {
            color: #1e1e1e; 
        }

        .legenda-id {
            font-weight: bold;
            color: #999999;
            width: 20px; /* Largura para o n√∫mero */
            flex-shrink: 0;
        }
        
        .timestamp {
            font-weight: bold;
            color: #5c7cfa;
            width: 100px; /* Largura para o tempo */
            flex-shrink: 0;
        }

        .legenda-texto {
            flex-grow: 1;
        }

        /* ================================== */
        /* Estilo para a √Årea de Edi√ß√£o */
        /* ================================== */
        #area-edicao {
            position: sticky;
            top: 0;
            background-color: #2d2d2d;
            z-index: 10;
            padding: 0;
        }

        .input-group {
            display: flex;
            margin: 10px;
            gap: 10px;
            align-items: center;
        }

        .input-group label {
            width: 50px; 
            flex-shrink: 0;
            font-weight: bold;
        }

        .input-campo {
            padding: 10px;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            font-size: 1em;
            background-color: #3a3a3a;
            color: #ffffff;
            box-sizing: border-box;
            flex-grow: 1; 
        }

        #input-inicio, #input-fim {
            width: 125px;
            flex-grow: 0;
        }

        #input-texto {
            min-height: 75px;
            /* Use 'normal' ou 'pre-wrap' (melhor para textos longos) */
            white-space: normal; 
            /* Garante que n√£o haja barra de rolagem horizontal desnecess√°ria */
            overflow-x: hidden; 
        }

        /* Estilo para os bot√µes */
        .botoes-time {
            display: flex; /* Transforma o bot√£o em um container flex */
            align-items: center; /* Alinha o conte√∫do verticalmente ao centro */
            justify-content: center; /* Alinha o conte√∫do horizontalmente ao centro */
            width: 25px;
            height: 45px;            
        }
        
        .botoes-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 7px;
            margin: 10px auto 0;
        }

        button {
            padding: 3px 6px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
            flex-basis: calc(20% - 7.5px); /*  */
        }

        #btn-desfazer, #btn-refazer {
            background-color: #f7931e;
            color: #1e1e1e;
        }

        #btn-desfazer:hover, #btn-refazer:hover  {
            background-color: #e6861a;
        }

        #btn-prev, #btn-play, #btn-next, #btn-linha\+, #btn-linha\- {
            background-color: #5c7cfa;
            color: #ffffff;
        }

        #btn-prev:hover, #btn-play:hover, #btn-next:hover, #btn-linha\+:hover, #btn-linha\-:hover {
            background-color: #4a67e6;
        }
        
        #btn-close {
            float: right; 
            font-size: 1.5rem;
            font-weight: bold; 
            cursor: pointer;
        }
    </style>
</head>
<body>

    <section id="load-area">
        <span id="btn-close" onclick="closeLoadSaveArea()">&times;</span>
        <p>üìÇ Abrir</p>
        <div class="load-group">
            <label for="videoUpload" class="upload-btn">Upload V√≠deo/√Åudio</label>
            <input type="text" id="videoUrl" placeholder="Cole a URL do v√≠deo/√°udio ou fa√ßa o upload">
            <input type="file" id="videoUpload" accept="video/*">
        </div>
        <div class="load-group">
        	<label for="srtUpload" class="upload-btn">Upload SRT</label>
        	<input type="text" id="srtUrl" placeholder="Cole a URL da legenda (.srt) ou fa√ßa o upload">
        	<input type="file" id="srtUpload" accept=".srt">
        </div>
            
		<div class="botoes-container">
            <button id="btn-open" onclick="openContent()">Carregar</button>
		</div>
    </section>

    <section id="save-area" class="hidden">
        <span id="btn-close" onclick="closeLoadSaveArea()">&times;</span>
        <p>Salvar</p>
        <div id="show-save-msg"></div>        
    </section>
    
    <section>
        <p>√Årea de Edi√ß√£o</p>
        <div id="area-edicao">
            
            <input type="hidden" id="input-id-edicao">

            <div class="input-group">
                <label for="input-inicio">In√≠cio:</label>
                <input type="text" id="input-inicio" class="input-campo" placeholder="Ex: 00:00:01,500">
                <button id="btn-inicio+" class="botoes-time">‚ûïÔ∏è</button>
                <button id="btn-inicio-" class="botoes-time">‚ûñ</button>
                <button id="btn-desfazer" class="botoes-time" disabled>‚Ü©Ô∏è</button>
                <button id="btn-refazer" class="botoes-time" disabled>‚Ü™Ô∏è</button>
            </div>

            <div class="input-group">
                <label for="input-fim">Fim:</label>
                <input type="text" id="input-fim" class="input-campo" placeholder="Ex: 00:00:04,000">
                <button id="btn-fim+" class="botoes-time">‚ûïÔ∏è</button>
                <button id="btn-fim-" class="botoes-time">‚ûñ</button>
                <button id="btn-linha+" class="botoes-time" disabled>‚ò∞ ‚ûïÔ∏è</button>
                <button id="btn-linha-" class="botoes-time" disabled>‚ò∞ ‚ûñ</button>
            </div>

			<div class="input-group">
                <label for="input-texto">Texto:</label>
                <textarea id="input-texto" class="input-campo" placeholder="Texto da legenda para edi√ß√£o"></textarea>
            </div>
            
            <div class="botoes-container">
                <button id="btn-load" onclick="showLoadArea()">üìÇ</button>
                <button id="btn-prev" disabled>‚óÄ‚óÄ</button>
                <button id="btn-play" disabled>‚ñ∂</button>
                <button id="btn-next" disabled>‚ñ∂‚ñ∂ </button>
                <button id="btn-save" onclick="showSaveArea()">üíæ</button>
            </div>
        </div>
    </section>

    <section>
        <p>Lista de Legendas (Clique em qualquer linha para editar)</p>
        <div id="lista-legendas">
            </div>
    </section>

    <script>
    // ==================================
    // Elementos do DOM
    // ==================================
    const listaLegendasDiv = document.getElementById('lista-legendas'); 
    const inputIdEdicao = document.getElementById('input-id-edicao'); 
    
    const inputInicio = document.getElementById('input-inicio');
    const inputFim = document.getElementById('input-fim');
    const inputTexto = document.getElementById('input-texto');
    const inputs = [inputInicio, inputFim, inputTexto];

    const btnDesfazer = document.getElementById('btn-desfazer');
    const btnRefazer = document.getElementById('btn-refazer');
    const btnLinhaAdicionar = document.getElementById('btn-linha+');
    const btnLinhaRemover = document.getElementById('btn-linha-');
    const btnPrevLinha = document.getElementById('btn-prev'); 
    const btnNextLinha = document.getElementById('btn-next');

    const btnInicioMais = document.getElementById('btn-inicio+');
    const btnInicioMenos = document.getElementById('btn-inicio-');
    const btnFimMais = document.getElementById('btn-fim+');
    const btnFimMenos = document.getElementById('btn-fim-');
    
    // ==================================
    // Estrutura de Dados e Hist√≥rico
    // ==================================
    // Estrutura de cada item: {id: number, inicio: string, fim: string, texto: string}
    const legendasIniciais = [
        { id: 1, inicio: '00:00:01,500', fim: '00:00:04,000', texto: 'Ol√°, bem-vindo ao nosso editor de legendas.' },
        { id: 2, inicio: '00:00:04,500', fim: '00:00:06,000', texto: 'Vamos falar sobre um tema muito interessante.' },
        { id: 3, inicio: '00:00:06,500', fim: '00:00:09,000', texto: 'Espero que voc√™ esteja preparado para aprender algo novo.' },
        { id: 4, inicio: '00:00:09,500', fim: '00:00:10,000', texto: 'Este foi apenas um exemplo.' },
        { id: 5, inicio: '00:00:10,500', fim: '00:00:12,000', texto: 'N√£o perca tempo e comece a editar suas legendas agora mesmo.' }
    ];

    // Estrutura de Dados e Hist√≥rico
    // Agora o hist√≥rico armazena um objeto com as legendas E o ID ativo
    let historico = [{ legendas: legendasIniciais, idAtivo: legendasIniciais[0].id }];
    let indiceHistorico = 0;
    
    // ==================================
    // --- Fun√ß√µes de Carregamento (Load) ---
    // ==================================

    /**
     * Inicia o carregamento do conte√∫do, seja por URL ou upload de arquivo.
     */
    function openContent() {
        const srtUrlInput = document.getElementById('srtUrl');
        const srtUploadInput = document.getElementById('srtUpload');
        const inputVideoUpload = document.getElementById('videoUpload'); // Use a ref. da DOM

        const url = srtUrlInput.value.trim();

        // 1. Carregar por URL (l√≥gica j√° existente)
        if (url) {
            carregarSRTporURL(url);
        } 
        // 2. Prioridade: Carregar √Åudio/V√≠deo por Arquivo
        else if (inputVideoUpload.files.length > 0) {
            carregarAudioPorArquivo(inputVideoUpload.files[0]);
        }
        // 3. Carregar SRT por Arquivo (se n√£o houver √°udio e houver SRT)
        else if (srtUploadInput.files.length > 0) {
            carregarSRTporArquivo(srtUploadInput.files[0]);
        } 
        // 4. Fechar
        else {
            closeLoadSaveArea();
        }
    }

    /**
     * Faz uma requisi√ß√£o HTTP para obter o conte√∫do do arquivo SRT de uma URL.
     * @param {string} url O URL direto para o arquivo .srt
     */
    function carregarSRTporURL(url) {
        if (!url.endsWith('.srt')) {
            alert('O URL fornecido n√£o parece ser um arquivo .srt.');
            return;
        }

        fetch(url)
            .then(response => {
                // Verifica se a resposta foi bem-sucedida (status 200)
                if (!response.ok) {
                    throw new Error(`Erro HTTP! Status: ${response.status}`);
                }
                // Retorna o conte√∫do da resposta como texto bruto
                return response.text();
            })
            .then(srtText => {
                // Chama a fun√ß√£o que ir√° converter o texto SRT em objetos de legenda
                processarSRTBruto(srtText);

                // Fecha a √°rea de carregamento ap√≥s o sucesso
                closeLoadSaveArea();
            })
            .catch(error => {
                alert(`Falha ao carregar o SRT do URL: ${error.message}. Verifique o CORS ou o URL.`);
                console.error('Erro de carregamento SRT via URL:', error);
            });
    }

    /**
     * L√™ o conte√∫do de um arquivo SRT carregado via <input type="file">.
     * @param {File} file O objeto File do input
     */
    function carregarSRTporArquivo(file) {
        const reader = new FileReader();

        reader.onload = function(e) {
            const srtText = e.target.result;
            processarSRTBruto(srtText);
            closeLoadSaveArea();
        };

        reader.onerror = function(e) {
            alert("Erro ao ler o arquivo SRT.");
            console.error('Erro de leitura do arquivo:', e);
        };

        reader.readAsText(file);
    }
    
    /**
     * Converte a string SRT bruta em um array de objetos de legenda.
     * @param {string} srtText O conte√∫do do arquivo SRT como string.
     */
    function processarSRTBruto(srtText) {
        // A regex busca blocos que come√ßam com um n√∫mero e um timestamp
        const blocos = srtText.trim().split(/\n\s*\n/);
        const novasLegendas = [];
        let idCounter = 1;

        blocos.forEach(bloco => {
            const linhas = bloco.trim().split('\n');

            // Se o primeiro item for um n√∫mero, remove ele (alguns arquivos n√£o t√™m o ID)
            if (!isNaN(parseInt(linhas[0]))) {
                linhas.shift();
            }

            if (linhas.length >= 2) {
                const timestampLinha = linhas[0];
                const texto = linhas.slice(1).join('\n').trim();

                const [inicioSrt, fimSrt] = timestampLinha.split(' --> ');

                // SRT usa '.' para milissegundos, mas nosso formato interno usa ','
                const inicio = inicioSrt.replace('.', ',');
                const fim = fimSrt.replace('.', ',');

                novasLegendas.push({
                    id: idCounter++, // Usa um novo ID limpo
                    inicio: inicio,
                    fim: fim,
                    texto: texto
                });
            }
        });

        if (novasLegendas.length > 0) {
            // Zera o hist√≥rico e define o novo estado
            historico = [{ legendas: novasLegendas, idAtivo: novasLegendas[0].id }];
            indiceHistorico = 0;

            // Aplica o novo estado, renderizando na tela e ativando o primeiro item
            aplicarEstado(historico[0]);
        } else {
            alert("Nenhuma legenda v√°lida encontrada no arquivo SRT.");
        }
    }
    
    /**
     * L√™ e decodifica um arquivo de √Åudio/V√≠deo carregado via <input type="file">.
     * @param {File} file O objeto File do input.
     */
    function carregarAudioPorArquivo(file) {
    	const inputVideoUpload = document.getElementById('videoUpload');
        
        // 1. Cria um novo contexto de √°udio (necess√°rio para a Web Audio API)
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        const reader = new FileReader();

        reader.onload = function(e) {
            const audioData = e.target.result; // ArrayBuffer com os dados do √°udio

            // 2. Decodifica o ArrayBuffer em um AudioBuffer
            audioContext.decodeAudioData(audioData)
                .then(audioBuffer => {
                    // SUCESSO: O AudioBuffer est√° pronto.
                    // Voc√™ pode armazen√°-lo em uma vari√°vel global para uso futuro.
                    window.audioBufferGlobal = audioBuffer; 

                    alert(`√Åudio carregado com sucesso! Dura√ß√£o: ${audioBuffer.duration.toFixed(2)} segundos.`);

                    // Exemplo de como voc√™ pode usar o AudioBuffer (voc√™ far√° isso depois)
                    // playAudio(audioBuffer, audioContext); 
                })
                .catch(error => {
                    alert("Erro ao decodificar o arquivo de √°udio.");
                    console.error('Erro de decodifica√ß√£o de √°udio:', error);
                });
        };

        reader.onerror = function(e) {
            alert("Erro ao ler o arquivo de √°udio.");
            console.error('Erro de leitura de arquivo:', e);
        };

        // 3. L√™ o arquivo como um ArrayBuffer (necess√°rio para decodeAudioData)
        reader.readAsArrayBuffer(file);
    }

    // ==================================
    // --- Fun√ß√µes de Navega√ß√£o (Views) ---
    // ==================================
    function showLoadArea() {
    document.getElementById('load-area').classList.remove('hidden');
    document.getElementById('save-area').classList.add('hidden');
    }

    function showSaveArea() {
        document.getElementById('save-area').classList.remove('hidden');
        document.getElementById('load-area').classList.add('hidden');
        copiarSRTparaClipboard();
    }

	function closeLoadSaveArea() {
        document.getElementById('load-area').classList.add('hidden');
        document.getElementById('save-area').classList.add('hidden');
	}

    // ==================================
    // Fun√ß√µes de Renderiza√ß√£o e Carregamento
    // ==================================

    /**
     * Renderiza a lista de legendas na tela (HTML).
     * @param {Array<Object>} legendas O array completo de legendas.
     */
    function renderizarLista(legendas) {
        listaLegendasDiv.innerHTML = ''; // Limpa a lista atual

        const idAtivo = parseInt(inputIdEdicao.value);

        legendas.forEach(legenda => {
            const itemDiv = document.createElement('div');
            itemDiv.setAttribute('data-id', legenda.id);
            itemDiv.classList.add('legenda-item');
            
            // Define a classe 'ativa' se for o item em foco
            if (legenda.id === idAtivo) {
                itemDiv.classList.add('legenda-ativa');
            }

            itemDiv.innerHTML = `
                <span class="legenda-id">${legenda.id}</span>
                <span class="timestamp">${legenda.inicio} --> ${legenda.fim}</span>
                <span class="legenda-texto">${legenda.texto}</span>
            `;
            
            // Adiciona o evento de clique para carregar o item para edi√ß√£o
            itemDiv.addEventListener('click', () => carregarLegendaParaEdicao(legenda.id, legendas));
            
            listaLegendasDiv.appendChild(itemDiv);
        });
    }

    /**
     * Carrega os dados de uma legenda espec√≠fica para os inputs de edi√ß√£o.
     * @param {number} id O ID da legenda a ser carregada.
     * @param {Array<Object>} legendas O array de legendas a ser consultado.
     */
    function carregarLegendaParaEdicao(id, legendas) {
        const legenda = legendas.find(l => l.id === id);
        if (!legenda) return;
        
        // Atualiza os inputs (ISSO FAZ O TEXTO APARECER)
        inputIdEdicao.value = legenda.id; // Define o ID sendo editado
        inputInicio.value = legenda.inicio;
        inputFim.value = legenda.fim;
        inputTexto.value = legenda.texto; // <--- AQUI O TEXTO √â DEFINIDO
        
        // CORRE√á√ÉO: REMOVA ESTE TRECHO
        // Force a re-renderiza√ß√£o/atualiza√ß√£o da lista ap√≥s carregar os inputs
        // renderizarLista(legendas); // <--- REMOVA ESTA LINHA!

        // Atualiza a classe ativa na lista renderizada
        document.querySelectorAll('.legenda-item').forEach(item => {
            item.classList.remove('legenda-ativa');
        });
        const itemAtivo = document.querySelector(`[data-id="${id}"]`);
        if (itemAtivo) {
            itemAtivo.classList.add('legenda-ativa');
        }
        
        atualizarBotoes(); // Garante que os bot√µes de navega√ß√£o e linha estejam atualizados
        inputTexto.focus();
    }
	
    // ==================================
    // Fun√ß√µes de Exporta√ß√£o (SRT)
    // ==================================

    /**
     * Converte o array de legendas para o formato de string SRT.
     * @param {Array<Object>} legendas O array completo de legendas.
     * @returns {string} O conte√∫do formatado no padr√£o SRT.
     */
    function gerarSRT(legendas) {
        let srtContent = '';

        legendas.forEach((legenda, index) => {
            // Formato SRT de tempo usa v√≠rgula para milissegundos
            const tempoInicio = legenda.inicio.replace(',', '.');
            const tempoFim = legenda.fim.replace(',', '.');

            // 1. N√∫mero da legenda
            // 2. Timestamps (HH:MM:SS,mmm --> HH:MM:SS,mmm)
            // 3. Texto
            // 4. Linha em branco

            srtContent += `${legenda.id}\n`;
            srtContent += `${tempoInicio} --> ${tempoFim}\n`;
            srtContent += `${legenda.texto}\n`;

            // Adiciona uma linha em branco, exceto ap√≥s a √∫ltima legenda
            if (index < legendas.length - 1) {
                srtContent += '\n';
            }
        });

        return srtContent;
    }

    /**
     * Copia todo o conte√∫do SRT formatado para a √°rea de transfer√™ncia.
     */
    function copiarSRTparaClipboard() {
        // 1. Garante que o estado mais recente (incluindo o que est√° sendo editado) seja salvo
        salvarEstado(); 

        // 2. Pega o array de legendas do √∫ltimo estado salvo no hist√≥rico
        const legendasAtuais = historico[indiceHistorico].legendas;

        // 3. Gera a string formatada em SRT
        const srtString = gerarSRT(legendasAtuais);
        
        // 3.1. Encontra o elemento pelo ID
        const showSaveMsg = document.getElementById('show-save-msg');

        // 4. Copia para o clipboard usando a API moderna (promisse)
        if (navigator.clipboard && navigator.clipboard.writeText) {
            // Limpa a mensagem anterior
            showSaveMsg.textContent = ''; 

            navigator.clipboard.writeText(srtString)
                .then(() => {
                    // Sucesso: Exibe a mensagem na div
                    showSaveMsg.textContent = '‚úÖ Conte√∫do SRT copiado para o clipboard! Voc√™ pode colar em um arquivo .srt.';
                })
                .catch(err => {
                    console.error('Erro ao copiar SRT: ', err);
                    // Falha: Exibe a mensagem de erro na div
                    showSaveMsg.textContent = '‚ùå Falha ao copiar. Verifique as permiss√µes do navegador.';
                });
        } else {
            // Fallback: Voc√™ tamb√©m deve direcionar a mensagem de fallback para a div, se houver
            const tempTextarea = document.createElement('textarea');
            tempTextarea.value = srtString;
            document.body.appendChild(tempTextarea);
            tempTextarea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextarea);

            // Mensagem de sucesso do fallback na div
            showSaveMsg.textContent = '‚úÖ Conte√∫do SRT copiado para o clipboard! (M√©todo de fallback)';
        }
	}
    // ==================================
    // Fun√ß√µes de Estado e Hist√≥rico (Desfazer/Refazer)
    // ==================================

    /**
     * Aplica um estado do hist√≥rico (o array completo de legendas).
     * @param {Object} estadoHistorico O objeto completo {legendas: Array, idAtivo: number}.
     */
    function aplicarEstado(estadoHistorico) {
        const { legendas, idAtivo } = estadoHistorico;

        // 1. Renderiza a lista na tela
        renderizarLista(legendas);

        // 2. Carrega o item que estava ativo quando este estado foi salvo
        // Isso garante que, ao Desfazer/Refazer, a √°rea de edi√ß√£o mostre a linha alterada.
        if (idAtivo && legendas.find(l => l.id === idAtivo)) {
            // Nota: carregarLegendaParaEdicao chama renderizarLista e atualizarBotoes internamente.
            carregarLegendaParaEdicao(idAtivo, legendas);
        } else if (legendas.length > 0) {
            carregarLegendaParaEdicao(legendas[0].id, legendas);
        }

        atualizarBotoes();
    }

    /**
     * Pega o estado atual de edi√ß√£o (o array completo)
     * @returns {Array<Object>} O array de legendas com o item editado atualizado.
     */
    function getEstadoAtual() {
        // Pega o estado atual do hist√≥rico e faz uma c√≥pia profunda (map)
        let estadoAtual = historico[indiceHistorico].legendas.map(item => ({...item}));

        const idAtivo = parseInt(inputIdEdicao.value);

        if (idAtivo) {
            const index = estadoAtual.findIndex(l => l.id === idAtivo);
            if (index !== -1) {
                estadoAtual[index] = {
                    id: idAtivo,
                    inicio: inputInicio.value.trim(),
                    fim: inputFim.value.trim(),
                    texto: inputTexto.value.trim()
                };
            }
        }
        return estadoAtual;
    }

    /**
     * Adiciona o estado atual ao hist√≥rico.
     */
    function salvarEstado() {
        const novoEstado = getEstadoAtual();
        const idAtivo = parseInt(inputIdEdicao.value);
        const ultimoEstado = historico[indiceHistorico]; 

        // Compara apenas as legendas para evitar salvar se s√≥ mudou o ID ativo (sele√ß√£o)
        if (JSON.stringify(novoEstado) === JSON.stringify(ultimoEstado.legendas)) {
            return;
        }

        historico = historico.slice(0, indiceHistorico + 1);

        // Adiciona o novo estado com as legendas E o ID ativo
        historico.push({ legendas: novoEstado, idAtivo: idAtivo });
        indiceHistorico = historico.length - 1;

        renderizarLista(novoEstado); 

        atualizarBotoes();
    }

    /**
     * Atualiza os atributos 'disabled' dos bot√µes Desfazer e Refazer.
     */
    function atualizarBotoes() {
        btnDesfazer.disabled = indiceHistorico <= 0;
        btnRefazer.disabled = indiceHistorico >= historico.length - 1;

        // Habilita Linha + se houver uma linha selecionada
        const idAtivo = parseInt(inputIdEdicao.value);
        btnLinhaAdicionar.disabled = !idAtivo;

        // Habilita Linha - se houver mais de uma linha
        const estadoAtual = historico[indiceHistorico].legendas;
        btnLinhaRemover.disabled = !idAtivo || estadoAtual.length <= 1;

        // Habilita/desabilita bot√µes de navega√ß√£o
        const indexAtual = estadoAtual.findIndex(l => l.id === idAtivo);
        // btnPrevLinha (Anterior)
        btnPrevLinha.disabled = !idAtivo || indexAtual <= 0;
        // btnNextLinha (Pr√≥ximo)
        btnNextLinha.disabled = !idAtivo || indexAtual >= estadoAtual.length - 1;
    }
    
    // ==================================
    // Valida√ß√£o e Formata√ß√£o de Timestamps
    // ==================================

    /**
     * Permite apenas n√∫meros e navega√ß√£o durante a digita√ß√£o
     */
    function permitirApenasNumerosTimestamp(e) {
        const tecla = e.key;

        // Permite: n√∫meros, Backspace, Delete, Tab, Escape, Enter, setas, Home, End
        if (
            /^\d$/.test(tecla) || // N√∫meros
            tecla === 'Backspace' ||
            tecla === 'Delete' ||
            tecla === 'Tab' ||
            tecla === 'Escape' ||
            tecla === 'Enter' ||
            tecla === 'ArrowLeft' ||
            tecla === 'ArrowRight' ||
            tecla === 'ArrowUp' ||
            tecla === 'ArrowDown' ||
            tecla === 'Home' ||
            tecla === 'End' ||
            (e.ctrlKey && (tecla === 'a' || tecla === 'c' || tecla === 'v' || tecla === 'x' || tecla === 'z')) // Ctrl+A, C, V, X, Z
        ) {
            return; // Permite
        }

        // Bloqueia v√≠rgula, dois pontos e outras teclas
        if (tecla === ',' || tecla === ':') {
            e.preventDefault();
            return;
        }

        e.preventDefault(); // Bloqueia outras teclas
    }

    /**
     * Formata o timestamp mantendo a estrutura HH:MM:SS,mmm
     */
    function formatarTimestampInput(input) {
        const cursorPos = input.selectionStart;
        let valor = input.value;

        // Extrai apenas os n√∫meros
        const numeros = valor.replace(/\D/g, '');

        // Se n√£o tiver n√∫meros suficientes, n√£o formata ainda
        if (numeros.length === 0) {
            input.value = '';
            return;
        }

        // Preenche com zeros √† esquerda at√© ter 7 d√≠gitos
        const preenchido = numeros.padStart(7, '0').slice(0, 7);

        // Formata: HH:MM:SS,mmm
        const horas = preenchido.slice(0, 2);
        const minutos = preenchido.slice(2, 4);
        const segundos = preenchido.slice(4, 6);
        const milissegundos = preenchido.slice(6, 7) + '00';

        const novoValor = `${horas}:${minutos}:${segundos},${milissegundos}`;
        input.value = novoValor;

        // Calcula nova posi√ß√£o do cursor
        // Conta quantos separadores (:, ) existem antes da posi√ß√£o do cursor
        let novaPosicao = cursorPos;
        const valorAnterior = valor.slice(0, cursorPos);
        const numerosAntes = valorAnterior.replace(/\D/g, '').length;

        // Ajusta posi√ß√£o baseado em onde est√° no formato HH:MM:SS,mmm
        if (numerosAntes <= 2) {
            novaPosicao = numerosAntes; // HH
        } else if (numerosAntes <= 4) {
            novaPosicao = numerosAntes + 1; // HH:MM
        } else if (numerosAntes <= 6) {
            novaPosicao = numerosAntes + 2; // HH:MM:SS
        } else {
            novaPosicao = numerosAntes + 3; // HH:MM:SS,mmm
        }

        input.setSelectionRange(novaPosicao, novaPosicao);
    }

    // Adiciona valida√ß√£o aos inputs de tempo
    inputInicio.addEventListener('keydown', permitirApenasNumerosTimestamp);
    inputFim.addEventListener('keydown', permitirApenasNumerosTimestamp);

    // Formata em tempo real durante a digita√ß√£o
    inputInicio.addEventListener('input', function() {
        formatarTimestampInput(this);
    });

    inputFim.addEventListener('input', function() {
        formatarTimestampInput(this);
    });

    // Blur para os inputs de tempo
    inputInicio.addEventListener('blur', salvarEstado);
    inputFim.addEventListener('blur', salvarEstado);
    
    // ==================================
    // Fun√ß√µes de Ajuste de Tempo
    // ==================================

    /**
     * Converte timestamp para milissegundos
     */
    function timestampParaMs(timestamp) {
        const partes = timestamp.split(':');
        const horas = parseInt(partes[0]);
        const minutos = parseInt(partes[1]);
        const segundosParte = partes[2].split(',');
        const segundos = parseInt(segundosParte[0]);
        const ms = parseInt(segundosParte[1]);

        return (horas * 3600000) + (minutos * 60000) + (segundos * 1000) + ms;
    }

    /**
     * Converte milissegundos para timestamp
     */
    function msParaTimestamp(totalMs) {
        // Garante que n√£o seja negativo
        totalMs = Math.max(0, totalMs);

        const h = Math.floor(totalMs / 3600000);
        const m = Math.floor((totalMs % 3600000) / 60000);
        const s = Math.floor((totalMs % 60000) / 1000);
        const ms = totalMs % 1000;

        return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')},${String(ms).padStart(3, '0')}`;
    }

    /**
     * Aumenta o tempo inicial (antecipa o in√≠cio)
     */
    function aumentarTempoInicial() {
        const inicioMs = timestampParaMs(inputInicio.value);
        const fimMs = timestampParaMs(inputFim.value);
        const novoInicioMs = Math.max(0, inicioMs + 100); // Antecipar in√≠cio (diminuir tempo)

        // Bloqueia se in√≠cio ultrapassar ou igualar o fim
        if (novoInicioMs >= fimMs) {
            return;
        }

        const idAtivo = parseInt(inputIdEdicao.value);
        const estadoAtual = historico[indiceHistorico].legendas;
        const indexAtual = estadoAtual.findIndex(l => l.id === idAtivo);

        if (indexAtual > 0) {
            const legendaAnterior = estadoAtual[indexAtual - 1];
            const fimAnteriorMs = timestampParaMs(legendaAnterior.fim);

            // Bloqueia se invadir legenda anterior
            if (novoInicioMs <= fimAnteriorMs) {
                return;
            }
        }

        inputInicio.value = msParaTimestamp(novoInicioMs);
        atualizarVisualizacaoLista();
    }

    function diminuirTempoInicial() {
        const inicioMs = timestampParaMs(inputInicio.value);
        const fimMs = timestampParaMs(inputFim.value);
        const novoInicioMs = inicioMs - 100; // Atrasa in√≠cio (aumenta tempo)

        // Bloqueia se novo in√≠cio for menor que zero
        if (novoInicioMs < 0) {
            return;
        }

        // Bloqueia se novo in√≠cio ultrapassar ou igualar o fim
        if (novoInicioMs >= fimMs) {
            return;
        }

        const idAtivo = parseInt(inputIdEdicao.value);
        const estadoAtual = historico[indiceHistorico].legendas;
        const indexAtual = estadoAtual.findIndex(l => l.id === idAtivo);

        if (indexAtual > 0) {
            const legendaAnterior = estadoAtual[indexAtual - 1];
            const fimAnteriorMs = timestampParaMs(legendaAnterior.fim);

            // Bloqueia se invadir a legenda anterior
            if (novoInicioMs <= fimAnteriorMs) {
                return;
            }
        }

        inputInicio.value = msParaTimestamp(novoInicioMs);
        atualizarVisualizacaoLista();
    }

    function aumentarTempoFinal() {
        const fimMs = timestampParaMs(inputFim.value);
        const novoFimMs = fimMs + 100; // Prolongar fim

        const idAtivo = parseInt(inputIdEdicao.value);
        const estadoAtual = historico[indiceHistorico].legendas;
        const indexAtual = estadoAtual.findIndex(l => l.id === idAtivo);

        if (indexAtual < estadoAtual.length - 1) {
            const legendaPosterior = estadoAtual[indexAtual + 1];
            const inicioPosteriorMs = timestampParaMs(legendaPosterior.inicio);

            // Bloqueia se invadir legenda posterior (novoFimMs igual ou maior que in√≠cio da posterior)
            if (novoFimMs >= inicioPosteriorMs) {
                return;
            }
        }

        inputFim.value = msParaTimestamp(novoFimMs);
        atualizarVisualizacaoLista();
    }

    function diminuirTempoFinal() {
        const inicioMs = timestampParaMs(inputInicio.value);
        const fimMs = timestampParaMs(inputFim.value);
        const novoFimMs = fimMs - 100; // Antecipar fim

        // Bloqueia se fim menor ou igual que in√≠cio
        if (novoFimMs <= inicioMs) {
            return;
        }

        const idAtivo = parseInt(inputIdEdicao.value);
        const estadoAtual = historico[indiceHistorico].legendas;
        const indexAtual = estadoAtual.findIndex(l => l.id === idAtivo);

        if (indexAtual < estadoAtual.length - 1) {
            const legendaPosterior = estadoAtual[indexAtual + 1];
            const inicioPosteriorMs = timestampParaMs(legendaPosterior.inicio);

            // Bloqueia se invadir legenda posterior (novoFimMs igual ou maior que in√≠cio da posterior)
            if (novoFimMs >= inicioPosteriorMs) {
                return;
            }
        }

        inputFim.value = msParaTimestamp(novoFimMs);
        atualizarVisualizacaoLista();
    }

    /**
     * Atualiza apenas a visualiza√ß√£o da lista sem salvar no hist√≥rico
     */
    function atualizarVisualizacaoLista() {
        const idAtivo = parseInt(inputIdEdicao.value);
        const itemDiv = document.querySelector(`[data-id="${idAtivo}"]`);
        if (itemDiv) {
            itemDiv.querySelector('.timestamp').textContent = `${inputInicio.value.trim()} --> ${inputFim.value.trim()}`;
        }
    }

    // ==================================
    // Event Listeners para Bot√µes de Ajuste
    // ==================================

    // Bot√µes de ajuste do tempo inicial
    btnInicioMais.addEventListener('click', () => {
        aumentarTempoInicial();
        inputInicio.focus();
    });

    btnInicioMenos.addEventListener('click', () => {
        diminuirTempoInicial();
        inputInicio.focus();
    });

    // Bot√µes de ajuste do tempo final
    btnFimMais.addEventListener('click', () => {
        aumentarTempoFinal();
        inputFim.focus();
    });

    btnFimMenos.addEventListener('click', () => {
        diminuirTempoFinal();
        inputFim.focus();
    });

    // Salva no hist√≥rico quando sair dos campos ap√≥s ajuste
    btnInicioMais.addEventListener('click', () => setTimeout(() => salvarEstado(), 500));
    btnInicioMenos.addEventListener('click', () => setTimeout(() => salvarEstado(), 500));
    btnFimMais.addEventListener('click', () => setTimeout(() => salvarEstado(), 500));
    btnFimMenos.addEventListener('click', () => setTimeout(() => salvarEstado(), 500));
    
    // ==================================
    // Event Listeners
    // ==================================
    
    // Evento de input apenas para atualizar a visualiza√ß√£o em tempo real
    inputs.forEach(input => {
        input.addEventListener('input', () => {
            const idAtivo = parseInt(inputIdEdicao.value);
            const itemDiv = document.querySelector(`[data-id="${idAtivo}"]`);
            if (itemDiv) {
                itemDiv.querySelector('.timestamp').textContent = `${inputInicio.value.trim()} --> ${inputFim.value.trim()}`;
                itemDiv.querySelector('.legenda-texto').textContent = inputTexto.value.trim();
            }
        });
    });

    // Blur apenas para o campo de texto
    inputTexto.addEventListener('blur', salvarEstado);
    
    // Bot√£o Desfazer
    btnDesfazer.addEventListener('click', () => {
        if (indiceHistorico > 0) {
            indiceHistorico--;
            aplicarEstado(historico[indiceHistorico]);
        }
    });

    // Bot√£o Refazer
    btnRefazer.addEventListener('click', () => {
        if (indiceHistorico < historico.length - 1) {
            indiceHistorico++;
            aplicarEstado(historico[indiceHistorico]);
        }
    });
    
    // Bot√£o Linha +
    btnLinhaAdicionar.addEventListener('click', adicionarLinha);

    // Bot√£o Linha -
    btnLinhaRemover.addEventListener('click', removerLinha);

    // Navega√ß√£o        
    btnPrevLinha.addEventListener('click', irParaLinhaAnterior);
    btnNextLinha.addEventListener('click', irParaProximaLinha);
    
    // ==================================
    // Fun√ß√µes de Adicionar/Remover Linhas
    // ==================================

    /**
     * Adiciona uma nova linha ap√≥s a linha selecionada
     */
    function adicionarLinha() {
        const idAtivo = parseInt(inputIdEdicao.value);
        if (!idAtivo) return;

        // Salva o estado atual antes de adicionar
        salvarEstado();

        const estadoAtual = historico[indiceHistorico].legendas.map(item => ({...item}));
        const indexAtual = estadoAtual.findIndex(l => l.id === idAtivo);

        if (indexAtual === -1) return;

        // Gera um novo ID (maior ID existente + 1)
        const novoId = Math.max(...estadoAtual.map(l => l.id)) + 1;

        // Pega o tempo de fim da linha atual como in√≠cio da nova linha
        const legendaAtual = estadoAtual[indexAtual];
        const inicioNovo = legendaAtual.fim;
        const fimNovo = calcularTempoSoma(inicioNovo, 2500); // Adiciona 2,5 segundos

        const novaLegenda = {
            id: novoId,
            inicio: inicioNovo,
            fim: fimNovo,
            texto: ''
        };

        // Insere a nova legenda ap√≥s a atual
        estadoAtual.splice(indexAtual + 1, 0, novaLegenda);

        // Salva o novo estado
        historico = historico.slice(0, indiceHistorico + 1);
        historico.push({ legendas: estadoAtual, idAtivo: novoId });
        indiceHistorico = historico.length - 1;

        aplicarEstado(historico[indiceHistorico]);
    }

    /**
     * Remove a linha selecionada
     */
    function removerLinha() {
        const idAtivo = parseInt(inputIdEdicao.value);
        if (!idAtivo) return;

        const estadoAtual = historico[indiceHistorico].legendas.map(item => ({...item}));

        // N√£o permite remover se s√≥ houver uma linha
        if (estadoAtual.length <= 1) {
            alert('N√£o √© poss√≠vel remover a √∫ltima legenda.');
            return;
        }

        const indexAtual = estadoAtual.findIndex(l => l.id === idAtivo);
        if (indexAtual === -1) return;

        // Remove a linha
        estadoAtual.splice(indexAtual, 1);

        // Define qual linha ficar√° ativa ap√≥s a remo√ß√£o
        let novoIdAtivo;
        if (indexAtual < estadoAtual.length) {
            // Se n√£o era a √∫ltima, ativa a pr√≥xima
            novoIdAtivo = estadoAtual[indexAtual].id;
        } else {
            // Se era a √∫ltima, ativa a anterior
            novoIdAtivo = estadoAtual[indexAtual - 1].id;
        }

        // Salva o novo estado
        historico = historico.slice(0, indiceHistorico + 1);
        historico.push({ legendas: estadoAtual, idAtivo: novoIdAtivo });
        indiceHistorico = historico.length - 1;

        aplicarEstado(historico[indiceHistorico]);
    }

    /**
     * Fun√ß√£o auxiliar para somar milissegundos a um timestamp
     */
    function calcularTempoSoma(timestamp, milissegundos) {
        // Converte timestamp "00:00:04,000" para milissegundos
        const partes = timestamp.split(':');
        const horas = parseInt(partes[0]);
        const minutos = parseInt(partes[1]);
        const segundosParte = partes[2].split(',');
        const segundos = parseInt(segundosParte[0]);
        const ms = parseInt(segundosParte[1]);

        const totalMs = (horas * 3600000) + (minutos * 60000) + (segundos * 1000) + ms + milissegundos;

        // Converte de volta para formato timestamp
        const h = Math.floor(totalMs / 3600000);
        const m = Math.floor((totalMs % 3600000) / 60000);
        const s = Math.floor((totalMs % 60000) / 1000);
        const msRestante = totalMs % 1000;

        return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')},${String(msRestante).padStart(3, '0')}`;
    }
    
    // ==================================
    // Fun√ß√µes de Navega√ß√£o Entre Linhas
    // ==================================

    /**
     * Navega para a linha anterior
     */
    function irParaLinhaAnterior() {
        const idAtivo = parseInt(inputIdEdicao.value);
        if (!idAtivo) return;

        const estadoAtual = historico[indiceHistorico].legendas;
        const indexAtual = estadoAtual.findIndex(l => l.id === idAtivo);

        if (indexAtual > 0) {
            // Salva o estado da LINHA ATUAL antes de mudar o foco
            salvarEstado();

            // Pega o estado atualizado ap√≥s salvar
            const novoEstado = historico[indiceHistorico].legendas;
            const linhaAnterior = novoEstado[indexAtual - 1];

            // Carrega a linha anterior.
            carregarLegendaParaEdicao(linhaAnterior.id, novoEstado);
        }
    }

    /**
     * Navega para a pr√≥xima linha
     */
    function irParaProximaLinha() {
        const idAtivo = parseInt(inputIdEdicao.value);
        if (!idAtivo) return;

        const estadoAtual = historico[indiceHistorico].legendas;
        const indexAtual = estadoAtual.findIndex(l => l.id === idAtivo);

        if (indexAtual < estadoAtual.length - 1) {
            // Salva o estado da LINHA ATUAL antes de mudar o foco
            salvarEstado();

            // Pega o estado atualizado ap√≥s salvar
            const novoEstado = historico[indiceHistorico].legendas;
            const proximaLinha = novoEstado[indexAtual + 1];

            // Carrega a pr√≥xima linha.
            carregarLegendaParaEdicao(proximaLinha.id, novoEstado);
        }
    }

    // ==================================
    // Inicializa√ß√£o
    // ==================================
    
    // Define o primeiro item como ativo para edi√ß√£o
    if (legendasIniciais.length > 0) {
        inputIdEdicao.value = legendasIniciais[0].id;
    }

    // Carrega o estado inicial (isto chama aplicarEstado, que chama carregarLegendaParaEdicao)
    aplicarEstado(historico[0])

</script>
</body>
</html>
