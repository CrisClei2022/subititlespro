<!-
'play, e carregar video e srt url' funcionando.
->
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SUBTITLE PRO - Editor de Legenda Multi-Trecho Dark</title>
    <style>
        /* ================================== */
        /* CSS B√°sico e Tema Dark */
        /* ================================== */
        body {
            font-family: Arial, sans-serif;
            background-color: #1e1e1e;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .hidden {
          display: none !important;
        }

        /*Show Info*/
        #info-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        #info-box {
            background: #2d2d2d;
            padding: 30px;
            border-radius: 8px;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
        }
        
        #info-message {
            margin-bottom: 20px;
            font-size: 1.1em;
            line-height: 1.5;
        }
        
        #info-btn-ok {
            background-color: #5c7cfa;
            color: #ffffff;
            padding: 10px 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1em;
        }
        
        #info-btn-ok:hover {
            background-color: #4a67e6;
        }
        
        section {
            padding: 10px;
            min-width: 350px; 
            max-width: 600px;
            border-radius: 8px;
            background-color: #2d2d2d;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        header h2 {
            text-align: center;
            margin: 20px 0;
            font-size: 2em;
            background: linear-gradient(90deg, #5c7cfa, #4a67e6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-transform: uppercase;
            letter-spacing: 3px;
            font-weight: bold;
        }

        .video-section {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
        }

        video {
            width: 100%;
            border-radius: 4px;
        }
        
        /* ================================== */
        /* Estilo para a Load e Save */
        /* ================================== */
		.load-group {
            display: flex;
            flex-direction: column;
            margin-top: 20px;
            gap: 8px;
            width: 100%;
        }
        
        /* ================================== */
        /* Estilo para a Lista de Legendas */
        /* ================================== */
        #lista-legendas {
            max-height: 50vh; /* ou a altura que preferir */
            overflow-y: auto;
            width: 100%;
        }
        
        .legenda-item {
            cursor: pointer;
            padding: 12px;
            margin-bottom: 8px;
            background: #333;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .legenda-item:hover {
            background-color: #444;
            transform: translateX(5px);
        }

        /* Marca√ß√£o para o item que est√° atualmente sendo editado */
        .legenda-item.legenda-ativa {
            background: #011b82;
            color: #e1e1e3;
            font-weight: bold;
        }

        .subtitle-time {
            font-size: 14px;
            color: #4CAF50;
            margin-bottom: 5px;
        }

        .subtitle-text {
            font-size: 16px;
        }

        /* ================================== */
        /* Estilo para a √Årea de Edi√ß√£o */
        /* ================================== */
        #area-edicao {
            position: sticky;
            top: 0;
            background-color: #2d2d2d;
            z-index: 10;
            padding: 0;
        }

        .input-group {
            display: flex;
            margin: 10px;
            gap: 10px;
            align-items: center;
        }

        .input-group label {
            width: 50px; 
            flex-shrink: 0;
            font-weight: bold;
        }

        .input-campo {
            padding: 10px;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            font-size: 1em;
            background-color: #3a3a3a;
            color: #ffffff;
            box-sizing: border-box;
            flex-grow: 1; 
        }

        #input-inicio, #input-fim {
            width: 125px;
            flex-grow: 0;
        }

        #input-texto {
            min-height: 75px;
            /* Use 'normal' ou 'pre-wrap' (melhor para textos longos) */
            white-space: normal; 
            /* Garante que n√£o haja barra de rolagem horizontal desnecess√°ria */
            overflow-x: hidden; 
        }

        /* Estilo para os bot√µes */
        .botoes-time {
            display: flex; /* Transforma o bot√£o em um container flex */
            align-items: center; /* Alinha o conte√∫do verticalmente ao centro */
            justify-content: center; /* Alinha o conte√∫do horizontalmente ao centro */
            width: 25px;
            height: 45px;            
        }
        
        .botoes-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 7px;
            margin: 10px auto 0;
        }

        button {
            padding: 3px 6px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
            flex-basis: calc(20% - 7.5px); /*  */
        }

        #btn-desfazer, #btn-refazer {
            background-color: #f7931e;
            color: #1e1e1e;
        }

        #btn-desfazer:hover, #btn-refazer:hover  {
            background-color: #e6861a;
        }

        #btn-prev, #btn-play, #btn-next, #btn-linha\+, #btn-linha\- {
            background-color: #5c7cfa;
            color: #ffffff;
        }

        #btn-prev:hover, #btn-play:hover, #btn-next:hover, #btn-linha\+:hover, #btn-linha\-:hover {
            background-color: #4a67e6;
        }
        
        #btn-close {
            float: right; 
            font-size: 1.5rem;
            font-weight: bold; 
            cursor: pointer;
        }
    </style>
</head>
<body>
	<header>
		<h2>SUBTITLE PRO</h2>
    </header>
    <section id="load-area">
        <span id="btn-close" onclick="closeLoadSaveArea()">&times;</span>
        <p>üìÇ Abrir</p>
        <div class="load-group">
            <label for="videoUpload" class="upload-btn">Upload V√≠deo</label>
            <input type="text" id="videoUrl" placeholder="Cole a URL do v√≠deo ou fa√ßa o upload">
            <input type="file" id="videoUpload" accept="video/*">
        </div>
        <div class="load-group">
        	<label for="srtUpload" class="upload-btn">Upload SRT</label>
        	<input type="text" id="srtUrl" placeholder="Cole a URL da legenda (.srt) ou fa√ßa o upload">
        	<input type="file" id="srtUpload" accept=".srt">
        </div>
            
		<div class="botoes-container">
            <button id="btn-open" onclick="openContent()">Carregar</button>
		</div>
    </section>

    <section id="save-area" class="hidden">
        <span id="btn-close" onclick="closeLoadSaveArea()">&times;</span>
        <p>Salvar</p>
        <div id="show-save-msg"></div>        
    </section>
    
    <section>
        <div id="area-edicao">
        	<p>√Årea de Edi√ß√£o</p>
            
            <input type="hidden" id="input-id-edicao">
            
            <div class="video-section">
                <video id="videoPlayer" controls></video>
            </div>

            <div class="input-group">
                <label for="input-inicio">In√≠cio:</label>
                <input type="text" id="input-inicio" class="input-campo" placeholder="Ex: 00:00:01,500">
                <button id="btn-inicio+" class="botoes-time">‚ûïÔ∏è</button>
                <button id="btn-inicio-" class="botoes-time">‚ûñ</button>
                <button id="btn-desfazer" class="botoes-time" disabled>‚Ü©Ô∏è</button>
                <button id="btn-refazer" class="botoes-time" disabled>‚Ü™Ô∏è</button>
            </div>

            <div class="input-group">
                <label for="input-fim">Fim:</label>
                <input type="text" id="input-fim" class="input-campo" placeholder="Ex: 00:00:04,000">
                <button id="btn-fim+" class="botoes-time">‚ûïÔ∏è</button>
                <button id="btn-fim-" class="botoes-time">‚ûñ</button>
                <button id="btn-linha+" class="botoes-time" disabled>‚ò∞ ‚ûïÔ∏è</button>
                <button id="btn-linha-" class="botoes-time" disabled>‚ò∞ ‚ûñ</button>
            </div>

			<div class="input-group">
                <label for="input-texto">Texto:</label>
                <textarea id="input-texto" class="input-campo" placeholder="Texto da legenda para edi√ß√£o"></textarea>
            </div>
            
            <div class="botoes-container">
                <button id="btn-load" onclick="showLoadArea()">üìÇ</button>
                <button id="btn-prev" disabled>‚óÄ‚óÄ</button>
                <button id="btn-play" onclick="playLine()">‚ñ∂</button>
                <button id="btn-next" disabled>‚ñ∂‚ñ∂ </button>
                <button id="btn-save" onclick="showSaveArea()">üíæ</button>
            </div>
        </div>
    </section>

    <section id="area-legendas">
        <p>Lista de Legendas (Clique em qualquer linha para editar)</p>
        <div id="lista-legendas">
            </div>
    </section>

    <div id="info-overlay">
        <div id="info-box">
            <div id="info-message"></div>
            <button id="info-btn-ok" onclick="closeInfo()">OK</button>
        </div>
    </div>
    
    <script>
    // ==================================
    // Elementos do DOM
    // ==================================
    const listaLegendasDiv = document.getElementById('lista-legendas'); 
    const inputIdEdicao = document.getElementById('input-id-edicao'); 
    
    const inputInicio = document.getElementById('input-inicio');
    const inputFim = document.getElementById('input-fim');
    const inputTexto = document.getElementById('input-texto');
    const inputs = [inputInicio, inputFim, inputTexto];

    const btnDesfazer = document.getElementById('btn-desfazer');
    const btnRefazer = document.getElementById('btn-refazer');
    const btnLinhaAdicionar = document.getElementById('btn-linha+');
    const btnLinhaRemover = document.getElementById('btn-linha-');
    const btnPrevLinha = document.getElementById('btn-prev'); 
    const btnNextLinha = document.getElementById('btn-next');

    const btnInicioMais = document.getElementById('btn-inicio+');
    const btnInicioMenos = document.getElementById('btn-inicio-');
    const btnFimMais = document.getElementById('btn-fim+');
    const btnFimMenos = document.getElementById('btn-fim-');
    
    // ==================================
    // Estrutura de Dados e Hist√≥rico
    // ==================================
    // Estrutura de cada item: {id: number, inicio: string, fim: string, texto: string}
    const legendasIniciais = [
        { id: 1, inicio: '00:00:01,500', fim: '00:00:04,000', texto: 'Ol√°, bem-vindo ao nosso v√≠deo de hoje.' },
        { id: 2, inicio: '00:00:04,500', fim: '00:00:06,000', texto: 'Vamos falar sobre um tema muito interessante.' },
        { id: 3, inicio: '00:00:06,500', fim: '00:00:09,000', texto: 'Espero que voc√™ esteja preparado para aprender algo novo.' },
        { id: 4, inicio: '00:00:09,500', fim: '00:00:10,000', texto: 'Espero que voc√™ esteja preparado para aprender algo novo.' },
        { id: 5, inicio: '00:00:10,500', fim: '00:00:12,000', texto: 'Espero que voc√™ esteja preparado para aprender algo novo.' }
    ];

    // Estrutura de Dados e Hist√≥rico
    // Agora o hist√≥rico armazena um objeto com as legendas E o ID ativo
    let historico = [{ legendas: legendasIniciais, idAtivo: legendasIniciais[0].id }];
    let indiceHistorico = 0;
    
    // ==================================
    // --- Fun√ß√µes de Navega√ß√£o (Views) ---
    // ==================================
    function showLoadArea() {
        document.getElementById('load-area').classList.remove('hidden');
        document.getElementById('save-area').classList.add('hidden');
        document.getElementById('area-edicao').classList.add('hidden');
        document.getElementById('area-legendas').classList.add('hidden');
    }

    function showSaveArea() {
        document.getElementById('save-area').classList.remove('hidden');
        document.getElementById('load-area').classList.add('hidden');
        document.getElementById('area-edicao').classList.add('hidden');
        document.getElementById('area-legendas').classList.add('hidden');
        copiarSRTparaClipboard();
    }

	function closeLoadSaveArea() {
        document.getElementById('load-area').classList.add('hidden');
        document.getElementById('save-area').classList.add('hidden');
        document.getElementById('area-edicao').classList.remove('hidden');
        document.getElementById('area-legendas').classList.remove('hidden');
	}

    // ==================================
    // Fun√ß√µes de Renderiza√ß√£o e Carregamento
    // ==================================

    /**
     * Renderiza a lista de legendas na tela (HTML).
     * @param {Array<Object>} legendas O array completo de legendas.
     */
    function renderizarLista(legendas) {
        listaLegendasDiv.innerHTML = ''; // Limpa a lista atual

        const idAtivo = parseInt(inputIdEdicao.value);

        legendas.forEach(legenda => {
            const itemDiv = document.createElement('div');
            itemDiv.setAttribute('data-id', legenda.id);
            itemDiv.classList.add('legenda-item');
            
            // Define a classe 'ativa' se for o item em foco
            if (legenda.id === idAtivo) {
                itemDiv.classList.add('legenda-ativa');
            }

            itemDiv.innerHTML = `
                <div class="subtitle-time">${legenda.inicio} --> ${legenda.fim}</div>
                <div class="subtitle-text">${legenda.texto}</div>
            `;
            
            // Adiciona o evento de clique para carregar o item para edi√ß√£o
            itemDiv.addEventListener('click', () => carregarLegendaParaEdicao(legenda.id, legendas));
            
            listaLegendasDiv.appendChild(itemDiv);
        });
    }

    /**
     * Carrega os dados de uma legenda espec√≠fica para os inputs de edi√ß√£o.
     * @param {number} id O ID da legenda a ser carregada.
     * @param {Array<Object>} legendas O array de legendas a ser consultado.
     */
    function carregarLegendaParaEdicao(id, legendas) {
        const legenda = legendas.find(l => l.id === id);
        if (!legenda) return;
        
        // Atualiza os inputs (ISSO FAZ O TEXTO APARECER)
        inputIdEdicao.value = legenda.id; // Define o ID sendo editado
        inputInicio.value = legenda.inicio;
        inputFim.value = legenda.fim;
        inputTexto.value = legenda.texto; // <--- AQUI O TEXTO √â DEFINIDO
        
        // CORRE√á√ÉO: REMOVA ESTE TRECHO
        // Force a re-renderiza√ß√£o/atualiza√ß√£o da lista ap√≥s carregar os inputs
        // renderizarLista(legendas); // <--- REMOVA ESTA LINHA!

        // Atualiza a classe ativa na lista renderizada
        document.querySelectorAll('.legenda-item').forEach(item => {
            item.classList.remove('legenda-ativa');
        });
        const itemAtivo = document.querySelector(`[data-id="${id}"]`);
        if (itemAtivo) {
            itemAtivo.classList.add('legenda-ativa');
        }
        
        atualizarBotoes(); // Garante que os bot√µes de navega√ß√£o e linha estejam atualizados
        inputTexto.focus();
    }
    
    // ==================================
    // Integra√ß√£o com V√≠deo
    // ==================================
    let videoPlayer = null;
    let stopTimeout = null;

    /**
     * Carrega o v√≠deo e o SRT a partir das URLs/arquivos fornecidos
     */
    async function openContent() {
        const videoUrl = document.getElementById('videoUrl').value.trim();
        const srtUrl = document.getElementById('srtUrl').value.trim();
        const videoUpload = document.getElementById('videoUpload').files[0];
        const srtUpload = document.getElementById('srtUpload').files[0];

        try {
            // Carrega o v√≠deo
            videoPlayer = document.getElementById('videoPlayer');
            if (videoUpload) {
                videoPlayer.src = URL.createObjectURL(videoUpload);
            } else if (videoUrl) {
                videoPlayer.src = videoUrl;
            }

            // Carrega o SRT
            let srtContent = '';
            if (srtUpload) {
                srtContent = await srtUpload.text();
            } else if (srtUrl) {
                const response = await fetch(srtUrl);
                if (!response.ok) throw new Error('Erro ao carregar arquivo SRT');
                srtContent = await response.text();
            }

            if (srtContent) {
                carregarSRTnoEditor(srtContent);
            }

            closeLoadSaveArea();
        } catch (error) {
            showInfo('Erro ao carregar conte√∫do: ' + error.message);
        }
    }

    /**
     * Converte o conte√∫do SRT para o formato do editor
     */
    function carregarSRTnoEditor(srtContent) {
        const linhas = srtContent.trim().split('\n');
        const novasLegendas = [];
        let i = 0;

        while (i < linhas.length) {
            if (linhas[i].trim() === '') {
                i++;
                continue;
            }

            const id = parseInt(linhas[i]);
            i++;

            if (isNaN(id)) continue;

            const timeLine = linhas[i];
            i++;

            const timeMatch = timeLine.match(/(\d{2}:\d{2}:\d{2}[,\.]\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2}[,\.]\d{3})/);
            if (!timeMatch) continue;

            const inicio = timeMatch[1].replace('.', ',');
            const fim = timeMatch[2].replace('.', ',');

            let texto = '';
            while (i < linhas.length && linhas[i].trim() !== '') {
                texto += linhas[i] + ' ';
                i++;
            }

            novasLegendas.push({
                id: id,
                inicio: inicio,
                fim: fim,
                texto: texto.trim()
            });
        }

        if (novasLegendas.length > 0) {
            // Reinicia o hist√≥rico com as novas legendas
            historico = [{ legendas: novasLegendas, idAtivo: novasLegendas[0].id }];
            indiceHistorico = 0;
            aplicarEstado(historico[0]);
        }
    }

    /**
     * Converte timestamp SRT para segundos
     */
    function timestampParaSegundos(timestamp) {
        const partes = timestamp.split(':');
        const horas = parseInt(partes[0]);
        const minutos = parseInt(partes[1]);
        const segundosParte = partes[2].split(',');
        const segundos = parseInt(segundosParte[0]);
        const ms = parseInt(segundosParte[1]);

        return horas * 3600 + minutos * 60 + segundos + ms / 1000;
    }

    /**
     * Toca o v√≠deo no tempo correspondente √† linha selecionada
     */
    function playLine() {
        if (!videoPlayer || !videoPlayer.src) {
            showInfo('Carregue um v√≠deo primeiro!');
            return;
        }

        const idAtivo = parseInt(inputIdEdicao.value);
        if (!idAtivo) {
            showInfo('Selecione uma linha primeiro!');
            return;
        }

        const legendaAtual = historico[indiceHistorico].legendas.find(l => l.id === idAtivo);
        if (!legendaAtual) return;

        // 1. Limpa qualquer parada agendada anteriormente
        if (stopTimeout) {
            clearTimeout(stopTimeout);
        }

        const tempoInicio = timestampParaSegundos(legendaAtual.inicio);
        const tempoFim = timestampParaSegundos(legendaAtual.fim);
        const duracaoMs = (tempoFim - tempoInicio) * 1000;

        // 2. Seta o tempo de in√≠cio e come√ßa a tocar
        videoPlayer.currentTime = tempoInicio;
        videoPlayer.play();

        // 3. Agenda a parada autom√°tica
        stopTimeout = setTimeout(() => {
            // Adiciona uma pequena toler√¢ncia (ex: 50ms) para garantir que a pausa ocorra ap√≥s o fim real.
            if (!videoPlayer.paused && videoPlayer.currentTime < tempoFim + 0.05) { 
                videoPlayer.pause();
                // Opcional: Para mover o cursor de tempo para o fim exato da legenda
                // videoPlayer.currentTime = tempoFim; 
            }
            stopTimeout = null; // Limpa o timeout ap√≥s a execu√ß√£o
        }, duracaoMs);
    }

    // ==================================
    // Fun√ß√µes de Exporta√ß√£o (SRT)
    // ==================================

    /**
     * Converte o array de legendas para o formato de string SRT.
     * @param {Array<Object>} legendas O array completo de legendas.
     * @returns {string} O conte√∫do formatado no padr√£o SRT.
     */
    function gerarSRT(legendas) {
        let srtContent = '';

        legendas.forEach((legenda, index) => {
            // Formato SRT de tempo usa v√≠rgula para milissegundos
            const tempoInicio = legenda.inicio.replace(',', '.');
            const tempoFim = legenda.fim.replace(',', '.');

            // 1. N√∫mero da legenda
            // 2. Timestamps (HH:MM:SS,mmm --> HH:MM:SS,mmm)
            // 3. Texto
            // 4. Linha em branco

            srtContent += `${legenda.id}\n`;
            srtContent += `${tempoInicio} --> ${tempoFim}\n`;
            srtContent += `${legenda.texto}\n`;

            // Adiciona uma linha em branco, exceto ap√≥s a √∫ltima legenda
            if (index < legendas.length - 1) {
                srtContent += '\n';
            }
        });

        return srtContent;
    }

    /**
     * Copia todo o conte√∫do SRT formatado para a √°rea de transfer√™ncia.
     */
    function copiarSRTparaClipboard() {
        // 1. Garante que o estado mais recente (incluindo o que est√° sendo editado) seja salvo
        salvarEstado(); 

        // 2. Pega o array de legendas do √∫ltimo estado salvo no hist√≥rico
        const legendasAtuais = historico[indiceHistorico].legendas;

        // 3. Gera a string formatada em SRT
        const srtString = gerarSRT(legendasAtuais);
        
        // 3.1. Encontra o elemento pelo ID
        const showSaveMsg = document.getElementById('show-save-msg');

        // 4. Copia para o clipboard usando a API moderna (promisse)
        if (navigator.clipboard && navigator.clipboard.writeText) {
            // Limpa a mensagem anterior
            showSaveMsg.textContent = ''; 

            navigator.clipboard.writeText(srtString)
                .then(() => {
                    // Sucesso: Exibe a mensagem na div
                    showSaveMsg.textContent = '‚úÖ Conte√∫do SRT copiado para o clipboard! Voc√™ pode colar em um arquivo .srt.';
                })
                .catch(err => {
                    console.error('Erro ao copiar SRT: ', err);
                    // Falha: Exibe a mensagem de erro na div
                    showSaveMsg.textContent = '‚ùå Falha ao copiar. Verifique as permiss√µes do navegador.';
                });
        } else {
            // Fallback: Voc√™ tamb√©m deve direcionar a mensagem de fallback para a div, se houver
            const tempTextarea = document.createElement('textarea');
            tempTextarea.value = srtString;
            document.body.appendChild(tempTextarea);
            tempTextarea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextarea);

            // Mensagem de sucesso do fallback na div
            showSaveMsg.textContent = '‚úÖ Conte√∫do SRT copiado para o clipboard! (M√©todo de fallback)';
        }
	}
    // ==================================
    // Fun√ß√µes de Estado e Hist√≥rico (Desfazer/Refazer)
    // ==================================

    /**
     * Aplica um estado do hist√≥rico (o array completo de legendas).
     * @param {Object} estadoHistorico O objeto completo {legendas: Array, idAtivo: number}.
     */
    function aplicarEstado(estadoHistorico) {
        const { legendas, idAtivo } = estadoHistorico;

        // 1. Renderiza a lista na tela
        renderizarLista(legendas);

        // 2. Carrega o item que estava ativo quando este estado foi salvo
        // Isso garante que, ao Desfazer/Refazer, a √°rea de edi√ß√£o mostre a linha alterada.
        if (idAtivo && legendas.find(l => l.id === idAtivo)) {
            // Nota: carregarLegendaParaEdicao chama renderizarLista e atualizarBotoes internamente.
            carregarLegendaParaEdicao(idAtivo, legendas);
        } else if (legendas.length > 0) {
            carregarLegendaParaEdicao(legendas[0].id, legendas);
        }

        atualizarBotoes();
    }

    /**
     * Pega o estado atual de edi√ß√£o (o array completo)
     * @returns {Array<Object>} O array de legendas com o item editado atualizado.
     */
    function getEstadoAtual() {
        // Pega o estado atual do hist√≥rico e faz uma c√≥pia profunda (map)
        let estadoAtual = historico[indiceHistorico].legendas.map(item => ({...item}));

        const idAtivo = parseInt(inputIdEdicao.value);

        if (idAtivo) {
            const index = estadoAtual.findIndex(l => l.id === idAtivo);
            if (index !== -1) {
                estadoAtual[index] = {
                    id: idAtivo,
                    inicio: inputInicio.value.trim(),
                    fim: inputFim.value.trim(),
                    texto: inputTexto.value.trim()
                };
            }
        }
        return estadoAtual;
    }

    /**
     * Adiciona o estado atual ao hist√≥rico.
     */
    function salvarEstado() {
        const novoEstado = getEstadoAtual();
        const idAtivo = parseInt(inputIdEdicao.value);
        const ultimoEstado = historico[indiceHistorico]; 
    
        // Compara legendas E id ativo - s√≥ ignora se AMBOS forem id√™nticos
        if (JSON.stringify(novoEstado) === JSON.stringify(ultimoEstado.legendas) && 
            idAtivo === ultimoEstado.idAtivo) {
            return;
        }

        historico = historico.slice(0, indiceHistorico + 1);

        // Adiciona o novo estado com as legendas E o ID ativo
        historico.push({ legendas: novoEstado, idAtivo: idAtivo });
        indiceHistorico = historico.length - 1;

        atualizarBotoes();
    }

    /**
     * Atualiza os atributos 'disabled' dos bot√µes Desfazer e Refazer.
     */
    function atualizarBotoes() {
        btnDesfazer.disabled = indiceHistorico <= 0;
        btnRefazer.disabled = indiceHistorico >= historico.length - 1;

        // Habilita Linha + se houver uma linha selecionada
        const idAtivo = parseInt(inputIdEdicao.value);
        btnLinhaAdicionar.disabled = !idAtivo;

        // Habilita Linha - se houver mais de uma linha
        const estadoAtual = historico[indiceHistorico].legendas;
        btnLinhaRemover.disabled = !idAtivo || estadoAtual.length <= 1;

        // Habilita/desabilita bot√µes de navega√ß√£o
        const indexAtual = estadoAtual.findIndex(l => l.id === idAtivo);
        // btnPrevLinha (Anterior)
        btnPrevLinha.disabled = !idAtivo || indexAtual <= 0;
        // btnNextLinha (Pr√≥ximo)
        btnNextLinha.disabled = !idAtivo || indexAtual >= estadoAtual.length - 1;
    }
    
    // ==================================
    // Valida√ß√£o e Formata√ß√£o de Timestamps
    // ==================================

    /**
     * Permite apenas n√∫meros e navega√ß√£o durante a digita√ß√£o
     */
    function permitirApenasNumerosTimestamp(e) {
        const tecla = e.key;

        // Permite: n√∫meros, Backspace, Delete, Tab, Escape, Enter, setas, Home, End
        if (
            /^\d$/.test(tecla) || // N√∫meros
            tecla === 'Backspace' ||
            tecla === 'Delete' ||
            tecla === 'Tab' ||
            tecla === 'Escape' ||
            tecla === 'Enter' ||
            tecla === 'ArrowLeft' ||
            tecla === 'ArrowRight' ||
            tecla === 'ArrowUp' ||
            tecla === 'ArrowDown' ||
            tecla === 'Home' ||
            tecla === 'End' ||
            (e.ctrlKey && (tecla === 'a' || tecla === 'c' || tecla === 'v' || tecla === 'x' || tecla === 'z')) // Ctrl+A, C, V, X, Z
        ) {
            return; // Permite
        }

        // Bloqueia v√≠rgula, dois pontos e outras teclas
        if (tecla === ',' || tecla === ':') {
            e.preventDefault();
            return;
        }

        e.preventDefault(); // Bloqueia outras teclas
    }

    /**
     * Formata o timestamp mantendo a estrutura HH:MM:SS,mmm
     */
    function formatarTimestampInput(input) {
        const cursorPos = input.selectionStart;
        let valor = input.value;

        // Extrai apenas os n√∫meros
        const numeros = valor.replace(/\D/g, '');

        // Se n√£o tiver n√∫meros suficientes, n√£o formata ainda
        if (numeros.length === 0) {
            input.value = '';
            return;
        }

        // Preenche com zeros √† esquerda at√© ter 7 d√≠gitos
        const preenchido = numeros.padStart(7, '0').slice(0, 7);

        // Formata: HH:MM:SS,mmm
        const horas = preenchido.slice(0, 2);
        const minutos = preenchido.slice(2, 4);
        const segundos = preenchido.slice(4, 6);
        const milissegundos = preenchido.slice(6, 7) + '00';

        const novoValor = `${horas}:${minutos}:${segundos},${milissegundos}`;
        input.value = novoValor;

        // Calcula nova posi√ß√£o do cursor
        // Conta quantos separadores (:, ) existem antes da posi√ß√£o do cursor
        let novaPosicao = cursorPos;
        const valorAnterior = valor.slice(0, cursorPos);
        const numerosAntes = valorAnterior.replace(/\D/g, '').length;

        // Ajusta posi√ß√£o baseado em onde est√° no formato HH:MM:SS,mmm
        if (numerosAntes <= 2) {
            novaPosicao = numerosAntes; // HH
        } else if (numerosAntes <= 4) {
            novaPosicao = numerosAntes + 1; // HH:MM
        } else if (numerosAntes <= 6) {
            novaPosicao = numerosAntes + 2; // HH:MM:SS
        } else {
            novaPosicao = numerosAntes + 3; // HH:MM:SS,mmm
        }

        input.setSelectionRange(novaPosicao, novaPosicao);
    }

    // Adiciona valida√ß√£o aos inputs de tempo
    inputInicio.addEventListener('keydown', permitirApenasNumerosTimestamp);
    inputFim.addEventListener('keydown', permitirApenasNumerosTimestamp);

    // Formata em tempo real durante a digita√ß√£o
    inputInicio.addEventListener('input', function() {
        formatarTimestampInput(this);
    });

    inputFim.addEventListener('input', function() {
        formatarTimestampInput(this);
    });

    // Blur para os inputs de tempo
    inputInicio.addEventListener('blur', salvarEstado);
    inputFim.addEventListener('blur', salvarEstado);
    
    // ==================================
    // Fun√ß√µes de Ajuste de Tempo
    // ==================================

    /**
     * Converte timestamp para milissegundos
     */
    function timestampParaMs(timestamp) {
        const partes = timestamp.split(':');
        const horas = parseInt(partes[0]);
        const minutos = parseInt(partes[1]);
        const segundosParte = partes[2].split(',');
        const segundos = parseInt(segundosParte[0]);
        const ms = parseInt(segundosParte[1]);

        return (horas * 3600000) + (minutos * 60000) + (segundos * 1000) + ms;
    }

    /**
     * Converte milissegundos para timestamp
     */
    function msParaTimestamp(totalMs) {
        // Garante que n√£o seja negativo
        totalMs = Math.max(0, totalMs);

        const h = Math.floor(totalMs / 3600000);
        const m = Math.floor((totalMs % 3600000) / 60000);
        const s = Math.floor((totalMs % 60000) / 1000);
        const ms = totalMs % 1000;

        return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')},${String(ms).padStart(3, '0')}`;
    }

    /**
     * Aumenta o tempo inicial (antecipa o in√≠cio)
     */
    function aumentarTempoInicial() {
        const inicioMs = timestampParaMs(inputInicio.value);
        const fimMs = timestampParaMs(inputFim.value);
        const novoInicioMs = Math.max(0, inicioMs + 100); // Antecipar in√≠cio (diminuir tempo)

        // Bloqueia se in√≠cio ultrapassar ou igualar o fim
        if (novoInicioMs >= fimMs) {
            return;
        }

        const idAtivo = parseInt(inputIdEdicao.value);
        const estadoAtual = historico[indiceHistorico].legendas;
        const indexAtual = estadoAtual.findIndex(l => l.id === idAtivo);

        if (indexAtual > 0) {
            const legendaAnterior = estadoAtual[indexAtual - 1];
            const fimAnteriorMs = timestampParaMs(legendaAnterior.fim);

            // Bloqueia se invadir legenda anterior
            if (novoInicioMs <= fimAnteriorMs) {
                return;
            }
        }

        inputInicio.value = msParaTimestamp(novoInicioMs);
        atualizarVisualizacaoLista();
    }

    function diminuirTempoInicial() {
        const inicioMs = timestampParaMs(inputInicio.value);
        const fimMs = timestampParaMs(inputFim.value);
        const novoInicioMs = inicioMs - 100; // Atrasa in√≠cio (aumenta tempo)

        // Bloqueia se novo in√≠cio for menor que zero
        if (novoInicioMs < 0) {
            return;
        }

        // Bloqueia se novo in√≠cio ultrapassar ou igualar o fim
        if (novoInicioMs >= fimMs) {
            return;
        }

        const idAtivo = parseInt(inputIdEdicao.value);
        const estadoAtual = historico[indiceHistorico].legendas;
        const indexAtual = estadoAtual.findIndex(l => l.id === idAtivo);

        if (indexAtual > 0) {
            const legendaAnterior = estadoAtual[indexAtual - 1];
            const fimAnteriorMs = timestampParaMs(legendaAnterior.fim);

            // Bloqueia se invadir a legenda anterior
            if (novoInicioMs <= fimAnteriorMs) {
                return;
            }
        }

        inputInicio.value = msParaTimestamp(novoInicioMs);
        atualizarVisualizacaoLista();
    }

    function aumentarTempoFinal() {
        const fimMs = timestampParaMs(inputFim.value);
        const novoFimMs = fimMs + 100; // Prolongar fim

        const idAtivo = parseInt(inputIdEdicao.value);
        const estadoAtual = historico[indiceHistorico].legendas;
        const indexAtual = estadoAtual.findIndex(l => l.id === idAtivo);

        if (indexAtual < estadoAtual.length - 1) {
            const legendaPosterior = estadoAtual[indexAtual + 1];
            const inicioPosteriorMs = timestampParaMs(legendaPosterior.inicio);

            // Bloqueia se invadir legenda posterior (novoFimMs igual ou maior que in√≠cio da posterior)
            if (novoFimMs >= inicioPosteriorMs) {
                return;
            }
        }

        inputFim.value = msParaTimestamp(novoFimMs);
        atualizarVisualizacaoLista();
    }

    function diminuirTempoFinal() {
        const inicioMs = timestampParaMs(inputInicio.value);
        const fimMs = timestampParaMs(inputFim.value);
        const novoFimMs = fimMs - 100; // Antecipar fim

        // Bloqueia se fim menor ou igual que in√≠cio
        if (novoFimMs <= inicioMs) {
            return;
        }

        const idAtivo = parseInt(inputIdEdicao.value);
        const estadoAtual = historico[indiceHistorico].legendas;
        const indexAtual = estadoAtual.findIndex(l => l.id === idAtivo);

        if (indexAtual < estadoAtual.length - 1) {
            const legendaPosterior = estadoAtual[indexAtual + 1];
            const inicioPosteriorMs = timestampParaMs(legendaPosterior.inicio);

            // Bloqueia se invadir legenda posterior (novoFimMs igual ou maior que in√≠cio da posterior)
            if (novoFimMs >= inicioPosteriorMs) {
                return;
            }
        }

        inputFim.value = msParaTimestamp(novoFimMs);
        atualizarVisualizacaoLista();
    }

    /**
     * Atualiza apenas a visualiza√ß√£o da lista sem salvar no hist√≥rico
     */
    function atualizarVisualizacaoLista() {
        const idAtivo = parseInt(inputIdEdicao.value);
        const itemDiv = document.querySelector(`[data-id="${idAtivo}"]`);
        if (itemDiv) {
            itemDiv.querySelector('.subtitle-time').textContent = `${inputInicio.value.trim()} --> ${inputFim.value.trim()}`;
        }
    }

    // ==================================
    // Event Listeners para Bot√µes de Ajuste
    // ==================================

    // Bot√µes de ajuste do tempo inicial
    btnInicioMais.addEventListener('click', () => {
        aumentarTempoInicial();
        inputInicio.focus();
    });

    btnInicioMenos.addEventListener('click', () => {
        diminuirTempoInicial();
        inputInicio.focus();
    });

    // Bot√µes de ajuste do tempo final
    btnFimMais.addEventListener('click', () => {
        aumentarTempoFinal();
        inputFim.focus();
    });

    btnFimMenos.addEventListener('click', () => {
        diminuirTempoFinal();
        inputFim.focus();
    });

    // Salva no hist√≥rico quando sair dos campos ap√≥s ajuste
    btnInicioMais.addEventListener('click', () => setTimeout(() => salvarEstado(), 500));
    btnInicioMenos.addEventListener('click', () => setTimeout(() => salvarEstado(), 500));
    btnFimMais.addEventListener('click', () => setTimeout(() => salvarEstado(), 500));
    btnFimMenos.addEventListener('click', () => setTimeout(() => salvarEstado(), 500));
    
    // ==================================
    // Event Listeners
    // ==================================
    
    // Evento de input apenas para atualizar a visualiza√ß√£o em tempo real
    inputs.forEach(input => {
        input.addEventListener('input', () => {
            const idAtivo = parseInt(inputIdEdicao.value);
            const itemDiv = document.querySelector(`[data-id="${idAtivo}"]`);
            if (itemDiv) {
                itemDiv.querySelector('.subtitle-time').textContent = `${inputInicio.value.trim()} --> ${inputFim.value.trim()}`;
                itemDiv.querySelector('.subtitle-text').textContent = inputTexto.value.trim();
            }
        });
    });

    // Blur apenas para o campo de texto
    inputTexto.addEventListener('blur', salvarEstado);
    
    // Bot√£o Desfazer
    btnDesfazer.addEventListener('click', () => {
        if (indiceHistorico > 0) {
            indiceHistorico--;
            aplicarEstado(historico[indiceHistorico]);
        }
    });

    // Bot√£o Refazer
    btnRefazer.addEventListener('click', () => {
        if (indiceHistorico < historico.length - 1) {
            indiceHistorico++;
            aplicarEstado(historico[indiceHistorico]);
        }
    });
    
    // Bot√£o Linha +
    btnLinhaAdicionar.addEventListener('click', adicionarLinha);

    // Bot√£o Linha -
    btnLinhaRemover.addEventListener('click', removerLinha);

    // Navega√ß√£o        
    btnPrevLinha.addEventListener('click', irParaLinhaAnterior);
    btnNextLinha.addEventListener('click', irParaProximaLinha);
    
    // ==================================
    // Fun√ß√µes de Adicionar/Remover Linhas
    // ==================================

    /**
     * Adiciona uma nova linha ap√≥s a linha selecionada
     */
    function adicionarLinha() {
        const idAtivo = parseInt(inputIdEdicao.value);
        if (!idAtivo) return;

        // Salva o estado atual antes de adicionar
        salvarEstado();

        const estadoAtual = historico[indiceHistorico].legendas.map(item => ({...item}));
        const indexAtual = estadoAtual.findIndex(l => l.id === idAtivo);

        if (indexAtual === -1) return;

        // Gera um novo ID (maior ID existente + 1)
        const novoId = Math.max(...estadoAtual.map(l => l.id)) + 1;

        // Pega o tempo de fim da linha atual como in√≠cio da nova linha
        const legendaAtual = estadoAtual[indexAtual];
        const inicioNovo = legendaAtual.fim;
        const fimNovo = calcularTempoSoma(inicioNovo, 2500); // Adiciona 2,5 segundos

        const novaLegenda = {
            id: novoId,
            inicio: inicioNovo,
            fim: fimNovo,
            texto: ''
        };

        // Insere a nova legenda ap√≥s a atual
        estadoAtual.splice(indexAtual + 1, 0, novaLegenda);

        // Salva o novo estado
        historico = historico.slice(0, indiceHistorico + 1);
        historico.push({ legendas: estadoAtual, idAtivo: novoId });
        indiceHistorico = historico.length - 1;

        aplicarEstado(historico[indiceHistorico]);
    }

    /**
     * Remove a linha selecionada
     */
    function removerLinha() {
        const idAtivo = parseInt(inputIdEdicao.value);
        if (!idAtivo) return;

        const estadoAtual = historico[indiceHistorico].legendas.map(item => ({...item}));

        // N√£o permite remover se s√≥ houver uma linha
        if (estadoAtual.length <= 1) {
            showInfo('N√£o √© poss√≠vel remover a √∫ltima legenda.');
            return;
        }

        const indexAtual = estadoAtual.findIndex(l => l.id === idAtivo);
        if (indexAtual === -1) return;

        // Remove a linha
        estadoAtual.splice(indexAtual, 1);

        // Define qual linha ficar√° ativa ap√≥s a remo√ß√£o
        let novoIdAtivo;
        if (indexAtual < estadoAtual.length) {
            // Se n√£o era a √∫ltima, ativa a pr√≥xima
            novoIdAtivo = estadoAtual[indexAtual].id;
        } else {
            // Se era a √∫ltima, ativa a anterior
            novoIdAtivo = estadoAtual[indexAtual - 1].id;
        }

        // Salva o novo estado
        historico = historico.slice(0, indiceHistorico + 1);
        historico.push({ legendas: estadoAtual, idAtivo: novoIdAtivo });
        indiceHistorico = historico.length - 1;

        aplicarEstado(historico[indiceHistorico]);
    }

    /**
     * Fun√ß√£o auxiliar para somar milissegundos a um timestamp
     */
    function calcularTempoSoma(timestamp, milissegundos) {
        // Converte timestamp "00:00:04,000" para milissegundos
        const partes = timestamp.split(':');
        const horas = parseInt(partes[0]);
        const minutos = parseInt(partes[1]);
        const segundosParte = partes[2].split(',');
        const segundos = parseInt(segundosParte[0]);
        const ms = parseInt(segundosParte[1]);

        const totalMs = (horas * 3600000) + (minutos * 60000) + (segundos * 1000) + ms + milissegundos;

        // Converte de volta para formato timestamp
        const h = Math.floor(totalMs / 3600000);
        const m = Math.floor((totalMs % 3600000) / 60000);
        const s = Math.floor((totalMs % 60000) / 1000);
        const msRestante = totalMs % 1000;

        return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')},${String(msRestante).padStart(3, '0')}`;
    }
    
    // ==================================
    // Fun√ß√µes de Navega√ß√£o Entre Linhas
    // ==================================

    /**
     * Navega para a linha anterior
     */
    function irParaLinhaAnterior() {
        const idAtivo = parseInt(inputIdEdicao.value);
        if (!idAtivo) return;
    
        const estadoAtual = historico[indiceHistorico].legendas;
        const indexAtual = estadoAtual.findIndex(l => l.id === idAtivo);
    
        if (indexAtual > 0) {
            // Salva ANTES de mudar
            salvarEstado();
    
            // Agora busca no hist√≥rico atualizado
            const estadoAtualizado = historico[indiceHistorico].legendas;
            const linhaAnterior = estadoAtualizado[indexAtual - 1];
    
            carregarLegendaParaEdicao(linhaAnterior.id, estadoAtualizado);
        }
    }

    /**
     * Navega para a pr√≥xima linha
     */
    function irParaProximaLinha() {
        const idAtivo = parseInt(inputIdEdicao.value);
        if (!idAtivo) return;
    
        const estadoAtual = historico[indiceHistorico].legendas;
        const indexAtual = estadoAtual.findIndex(l => l.id === idAtivo);
    
        if (indexAtual < estadoAtual.length - 1) {
            // Salva ANTES de mudar
            salvarEstado();
    
            // Agora busca no hist√≥rico atualizado
            const estadoAtualizado = historico[indiceHistorico].legendas;
            const proximaLinha = estadoAtualizado[indexAtual + 1];
    
            carregarLegendaParaEdicao(proximaLinha.id, estadoAtualizado);
        }
    }

    function showInfo(message) {
        document.getElementById('info-message').textContent = message;
        document.getElementById('info-overlay').style.display = 'flex';
    }
    
    function closeInfo() {
        document.getElementById('info-overlay').style.display = 'none';
    }

    // ==================================
    // Inicializa√ß√£o
    // ==================================
    
    // Define o primeiro item como ativo para edi√ß√£o
    if (legendasIniciais.length > 0) {
        inputIdEdicao.value = legendasIniciais[0].id;
    }

    // Carrega o estado inicial (isto chama aplicarEstado, que chama carregarLegendaParaEdicao)
    aplicarEstado(historico[0])
    showLoadArea();

</script>
</body>
</html>
