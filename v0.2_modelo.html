<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Editor SRT com Undo/Redo e ajuste de tempo</title>
<style>
  body { font-family: Arial; margin: 20px; background: #f5f5f5; }
  .segment { background: white; padding: 10px; border-radius: 10px; margin: 5px 0; cursor: pointer; transition: 0.2s; }
  .segment:hover { background: #e7f0ff; transform: scale(1.01); }
  .editor { background: white; border-radius: 10px; padding: 15px; margin-top: 15px; box-shadow: 0 0 5px rgba(0,0,0,0.1); }
  input, textarea { width: calc(100% - 40px); margin-top: 5px; margin-bottom: 10px; padding: 6px; font-size: 14px; }
  button { margin: 3px; padding: 6px 10px; font-size: 14px; cursor: pointer; }
  .time-controls { display: flex; align-items: center; gap: 5px; }
  label { font-weight: bold; display: block; margin-top: 10px; }
</style>
</head>
<body>

<h2>Legendas (SRT curto)</h2>
<div id="segments"></div>

<div class="editor" id="editor" style="display:none;">
  <h3>EdiÃ§Ã£o do trecho</h3>

  <label>InÃ­cio</label>
  <div class="time-controls">
    <input id="editStart">
    <button onclick="adjustTime('start', -0.5)">âˆ’</button>
    <button onclick="adjustTime('start', +0.5)">+</button>
  </div>

  <label>Fim</label>
  <div class="time-controls">
    <input id="editEnd">
    <button onclick="adjustTime('end', -0.5)">âˆ’</button>
    <button onclick="adjustTime('end', +0.5)">+</button>
  </div>

  <label>Texto</label>
  <textarea id="editText" rows="3"></textarea>

  <button onclick="undo()">â†© Desfazer</button>
  <button onclick="redo()">â†ª Refazer</button>
</div>

<script>
const srtData = [
  { id: 1, start: "00:00:01,000", end: "00:00:03,000", text: "OlÃ¡, mundo!" },
  { id: 2, start: "00:00:04,000", end: "00:00:06,000", text: "Bem-vindo ao editor de legendas." },
  { id: 3, start: "00:00:07,000", end: "00:00:09,000", text: "Aqui vocÃª pode editar e desfazer aÃ§Ãµes." }
];

let currentSegment = null;
let undoStack = [];
let redoStack = [];

function renderSegments() {
  const container = document.getElementById("segments");
  container.innerHTML = "";
  srtData.forEach(seg => {
    const div = document.createElement("div");
    div.className = "segment";
    div.innerHTML = `<b>${seg.id}</b> [${seg.start} â†’ ${seg.end}]<br>${seg.text}`;
    div.onclick = () => openEditor(seg.id);
    container.appendChild(div);
  });
}

function openEditor(id) {
  currentSegment = srtData.find(s => s.id === id);
  if (!currentSegment) return;

  document.getElementById("editor").style.display = "block";
  document.getElementById("editStart").value = currentSegment.start;
  document.getElementById("editEnd").value = currentSegment.end;
  document.getElementById("editText").value = currentSegment.text;

  document.getElementById("editStart").oninput = e => handleChange("start", e.target.value);
  document.getElementById("editEnd").oninput = e => handleChange("end", e.target.value);
  document.getElementById("editText").oninput = e => handleChange("text", e.target.value);
}

function handleChange(field, newValue) {
  if (!currentSegment) return;
  const oldValue = currentSegment[field];
  if (oldValue === newValue) return;

  undoStack.push({ id: currentSegment.id, field, oldValue, newValue });
  redoStack = [];
  currentSegment[field] = newValue;
  renderSegments();
}

function adjustTime(field, deltaSeconds) {
  if (!currentSegment) return;

  const oldValue = currentSegment[field];
  const newValue = shiftTime(oldValue, deltaSeconds);

  // ðŸ”¹ Verificar se o novo tempo nÃ£o invade outro segmento
  const idx = srtData.findIndex(s => s.id === currentSegment.id);
  const prev = srtData[idx - 1];
  const next = srtData[idx + 1];

  // Converter tempos para milissegundos para comparaÃ§Ã£o
  const toMs = t => {
    const [h, m, rest] = t.split(":");
    const [s, ms] = rest.split(",");
    return (+h * 3600 + +m * 60 + +s) * 1000 + +ms;
  };

  const newMs = toMs(newValue);
  const startMs = toMs(currentSegment.start);
  const endMs = toMs(currentSegment.end);

  // ðŸ”¸ Impedir que o inÃ­cio ultrapasse o fim do anterior
  if (field === "start" && prev && newMs <= toMs(prev.end) + 300) return; // margem de 0.3s

  // ðŸ”¸ Impedir que o fim ultrapasse o inÃ­cio do prÃ³ximo
  if (field === "end" && next && newMs >= toMs(next.start) - 300) return; // margem de 0.3s

  // ðŸ”¸ Impedir que inÃ­cio ultrapasse o prÃ³prio fim
  if (field === "start" && newMs >= endMs - 200) return;
  if (field === "end" && newMs <= startMs + 200) return;
  
  undoStack.push({ id: currentSegment.id, field, oldValue, newValue });
  redoStack = [];

  currentSegment[field] = newValue;
  updateEditorFields(currentSegment);
  renderSegments();
}

function shiftTime(timeStr, delta) {
  // "00:00:04,500" â†’ soma delta (em segundos)
  const [h, m, rest] = timeStr.split(":");
  const [s, ms] = rest.split(",");
  let totalMs = (+h * 3600 + +m * 60 + +s) * 1000 + +ms + delta * 1000;

  if (totalMs < 0) totalMs = 0;
  const hours = Math.floor(totalMs / 3600000);
  const minutes = Math.floor((totalMs % 3600000) / 60000);
  const seconds = Math.floor((totalMs % 60000) / 1000);
  const millis = Math.floor(totalMs % 1000);
  return `${pad(hours)}:${pad(minutes)}:${pad(seconds)},${pad(millis, 3)}`;
}

function pad(num, size=2) {
  return num.toString().padStart(size, "0");
}

function undo() {
  if (!undoStack.length) return;
  const last = undoStack.pop();
  redoStack.push(last);

  const seg = srtData.find(s => s.id === last.id);
  if (!seg) return;

  seg[last.field] = last.oldValue;
  
    if (currentSegment && currentSegment.id === last.id) updateEditorFields(seg);

  // ðŸ”¹ Atualiza o editor para mostrar o segmento afetado
  currentSegment = seg;        // muda o editor para este segmento
  updateEditorFields(seg);     // atualiza os campos visÃ­veis

  renderSegments();
}

function redo() {
  if (!redoStack.length) return;
  const last = redoStack.pop();
  undoStack.push(last);

  const seg = srtData.find(s => s.id === last.id);
  if (!seg) return;

  seg[last.field] = last.newValue;
  
  if (currentSegment && currentSegment.id === last.id) updateEditorFields(seg);
  
    // ðŸ”¹ Atualiza o editor para mostrar o segmento afetado
  currentSegment = seg;        // muda o editor para este segmento
  updateEditorFields(seg);     // atualiza os campos visÃ­veis
  
  renderSegments();
}

function updateEditorFields(seg) {
  document.getElementById("editStart").value = seg.start;
  document.getElementById("editEnd").value = seg.end;
  document.getElementById("editText").value = seg.text;
}

document.addEventListener("keydown", e => {
  if (e.ctrlKey && e.key === "z") { e.preventDefault(); undo(); }
  if (e.ctrlKey && e.key === "y") { e.preventDefault(); redo(); }
});

renderSegments();
</script>
</body>
</html>
